{
  "$comment": "Missio-specific schema extensions. Merged into opencollectionschema-source.json at build time to produce opencollectionschema.json. Each entry describes a JSON Schema patch: where to inject properties and what $defs to add.",
  "justifications": [
    {
      "extension": "SecretProvider + secretProviders",
      "reason": "The OpenCollection spec has no concept of external secret resolution. Missio integrates with Azure Key Vault (and potentially other providers) to resolve secret variable references at runtime, keeping sensitive values out of YAML files entirely."
    },
    {
      "extension": "forceAuthInherit",
      "reason": "The spec's auth inheritance chain (request → folder → collection) doesn't provide a way to enforce collection-level auth globally. Enterprise collections often need a single OAuth2 config applied uniformly, without risk of individual requests overriding it."
    },
    {
      "extension": "credentialsId (on OAuth2 flows)",
      "reason": "The spec's OAuth2 token storage is keyed by access token URL, but real-world scenarios require multiple credential sets against the same identity provider (e.g. different client IDs for different tenants). credentialsId disambiguates token storage keys."
    },
    {
      "extension": "AuthCli",
      "reason": "The spec has no concept of CLI-based token acquisition. Many enterprise environments use CLI tools (az, gcloud, aws, oci, kubectl) to obtain bearer tokens. AuthCli allows declarative CLI command execution with caching, avoiding the need for pre-request scripts."
    }
  ],
  "definitions": {
    "AuthCliCache": {
      "type": "object",
      "description": "Cache settings for CLI-based auth tokens",
      "properties": {
        "enabled": {
          "type": "boolean",
          "description": "Whether to cache the token (default true)"
        },
        "ttlSeconds": {
          "type": "integer",
          "description": "Time-to-live in seconds for cached tokens. If omitted, Missio attempts to parse JWT expiry."
        }
      },
      "additionalProperties": false
    },
    "AuthCli": {
      "type": "object",
      "description": "CLI-based auth: executes a command to obtain a bearer token",
      "properties": {
        "type": {
          "type": "string",
          "const": "cli"
        },
        "command": {
          "type": "string",
          "description": "Shell command to execute. Output should be the raw token. Supports {{var}} interpolation."
        },
        "tokenHeader": {
          "type": "string",
          "description": "Header name to inject the token into (default: Authorization)"
        },
        "tokenPrefix": {
          "type": "string",
          "description": "Prefix before the token value (default: Bearer). Set to empty string for raw token."
        },
        "cache": {
          "$ref": "#/$defs/AuthCliCache"
        }
      },
      "required": ["type", "command"],
      "additionalProperties": false
    },
    "SecretProvider": {
      "type": "object",
      "description": "A secret provider for resolving secret variables at runtime",
      "properties": {
        "name": {
          "type": "string",
          "description": "The name of the secret provider"
        },
        "type": {
          "type": "string",
          "enum": ["azure-keyvault"],
          "description": "The type of secret provider"
        },
        "namespace": {
          "type": "string",
          "description": "The namespace identifier (e.g. vault name for Azure Key Vault), supports {{var}} interpolation"
        },
        "subscription": {
          "type": "string",
          "description": "Azure subscription ID or name (for cross-subscription vaults)"
        },
        "disabled": {
          "type": "boolean",
          "description": "Whether the secret provider is disabled"
        }
      },
      "required": ["name", "type", "namespace"],
      "additionalProperties": false
    }
  },
  "patches": [
    {
      "description": "Add secretProviders array to CollectionConfig",
      "target": "$defs/CollectionConfig/properties",
      "properties": {
        "secretProviders": {
          "type": "array",
          "description": "Array of secret providers for resolving secret variables",
          "items": {
            "$ref": "#/$defs/SecretProvider"
          }
        }
      }
    },
    {
      "description": "Add forceAuthInherit to CollectionConfig for overriding auth inheritance",
      "target": "$defs/CollectionConfig/properties",
      "properties": {
        "forceAuthInherit": {
          "type": "boolean",
          "description": "When true, all requests in this collection use the collection-level auth, ignoring request and folder auth settings"
        }
      }
    },
    {
      "description": "Add credentialsId to OAuth2ClientCredentialsFlow",
      "target": "$defs/OAuth2ClientCredentialsFlow/properties",
      "properties": {
        "credentialsId": {
          "type": "string",
          "description": "Identifier for distinguishing multiple credential sets for the same token URL"
        }
      }
    },
    {
      "description": "Add credentialsId to OAuth2ResourceOwnerPasswordFlow",
      "target": "$defs/OAuth2ResourceOwnerPasswordFlow/properties",
      "properties": {
        "credentialsId": {
          "type": "string",
          "description": "Identifier for distinguishing multiple credential sets for the same token URL"
        }
      }
    },
    {
      "description": "Add credentialsId to OAuth2AuthorizationCodeFlow",
      "target": "$defs/OAuth2AuthorizationCodeFlow/properties",
      "properties": {
        "credentialsId": {
          "type": "string",
          "description": "Identifier for distinguishing multiple credential sets for the same token URL"
        }
      }
    },
    {
      "description": "Add AuthCli to Auth oneOf",
      "target": "$defs/Auth/oneOf",
      "items": [
        { "$ref": "#/$defs/AuthCli" }
      ]
    }
  ]
}
